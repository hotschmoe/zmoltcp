# zmoltcp Dual-Stack Plan

Date: 2026-02-24
Goal: Feature parity with smoltcp via comptime-parameterized dual-stack IPv4/IPv6

## Completion Status

- Phase 0: Comptime Refactor -- COMPLETE (524 tests)
- Phase 1: IPv6 Wire Formats -- COMPLETE (592 tests)
- Phase 2: IPv6 Iface + Stack Integration -- COMPLETE (676 tests)
  - NDP neighbor cache, ICMPv6 echo/error, MLD multicast, SLAAC
  - All v6 socket types: TCP6, UDP6, ICMPv6, Raw6, DNS6
  - IPv6 fragment reassembly with extension header walking
  - IPv6 egress dispatch, pollAt integration
  - Mandatory UDP/TCP/ICMPv6 checksums over IPv6
- Phase 3: Medium::Ip -- COMPLETE (687 tests)
  - Raw IP medium support (TUN, PPP) via comptime Medium enum
  - IP-medium ingress: version nibble dispatch, no Ethernet framing
  - IP-medium egress: skip MAC resolution, write IP at buf[0]
  - Guards for ARP/NDP/MLD/SLAAC on IP medium
  - PHY middleware propagates medium from inner Device
- Phase 4: IoT / Constrained Networks -- COMPLETE (818 tests)
  - IEEE 802.15.4 MAC frame parse/emit (addressing modes, PAN ID)
  - 6LoWPAN IPHC/NHC compression/decompression (RFC 6282)
  - 6LoWPAN fragmentation (FRAG1/FRAGN)
  - RPL wire format: DIS/DIO/DAO/DAO-ACK (RFC 6550)
  - RPL state machine: TrickleTimer, OF0, ParentSet, Relations
  - Stack integration: 802.15.4 medium, 6LoWPAN pipeline, IPv6-only
- Phase 5: Polish and Remaining Features -- COMPLETE (726 tests)
  - 5.4: Configurable auto_icmp_echo_reply on Interface (+3 tests)
  - 5.1: IPsec ESP/AH wire formats (+12 tests)
  - 5.3: PcapWriter PHY middleware (+7 tests)
  - 5.2: mDNS querier extending DNS socket (+4 tests)
  - 5.5: PacketBuffer dual-ring + UDP/ICMP migration (+12 tests, 0 net socket tests)

## Original State (at plan creation)

521 tests passing. Full IPv4 feature parity with smoltcp:
TCP (full state machine, SACK, timestamps, Reno/Cubic), UDP, ICMPv4, ARP, IGMP,
DHCPv4, DNS, Raw sockets, IPv4 fragmentation/reassembly, routing table, neighbor
cache, device capabilities, checksum offload, PHY middleware (Tracer/FaultInjector).

## Design Decision: Comptime Parameterization

Instead of smoltcp's runtime `IpAddress` enum (`v4([4]u8) | v6([16]u8)`), we use
Zig's comptime generics. Each socket, endpoint, and routing type is parameterized
over an `Ip` type that satisfies a compile-time contract. The compiler generates
fully specialized code for each IP version. Zero runtime branching on address type.

Why:
- Zero-cost abstraction -- no enum tag checks in the hot path
- Type safety -- cannot accidentally pass a v6 address to a v4 socket
- Dead code elimination -- a v4-only build contains no v6 code at all
- Idiomatic Zig -- this is exactly what comptime generics are for

Trade-off:
- A dual-stack stack instantiates both v4 and v6 socket types (more generated code)
- Cannot have a single "any-IP" socket (each socket is typed to one version)
  This matches real-world practice: even Linux separates AF_INET and AF_INET6.

---

## Three-Tier Classification

Every module in the codebase falls into one of three tiers:

```
+================================================================+
|  TIER 1: PROTOCOL-INHERENT (no parameterization possible)      |
|                                                                |
|  IPv4-only:                  | IPv6-only (NEW):               |
|    wire/arp.zig              |   wire/ipv6.zig                 |
|    wire/ipv4.zig             |   wire/icmpv6.zig               |
|    wire/igmp.zig             |   wire/ndisc.zig                |
|    wire/dhcp.zig             |   wire/ndiscoption.zig          |
|    socket/dhcp.zig           |   wire/mld.zig                  |
|    fragmentation.zig (v4)    |   wire/ipv6fragment.zig         |
|    iface: ARP neighbor cache |   wire/ipv6hbh.zig              |
|    iface: IGMP multicast     |   wire/ipv6option.zig           |
|    iface: processArp()       |   wire/ipv6routing.zig          |
|                              |   iface: NDP neighbor cache     |
|                              |   iface: MLD multicast          |
|                              |   iface: SLAAC                  |
|                              |   iface: processIpv6()          |
+================================================================+
|  TIER 2: GENERIC OVER Ip (the refactor surface)               |
|                                                                |
|    Endpoint(Ip)       = struct { addr: Ip.Address, port: u16 } |
|    ListenEndpoint(Ip) = struct { addr: ?Ip.Address, port: u16 }|
|    IpCidr(Ip)         = struct { address: Ip.Address, ... }    |
|    Route(Ip)          = struct { cidr: IpCidr(Ip), via: ... }  |
|    IpMeta(Ip)         = struct { src/dst: Ip.Address, ... }    |
|    socket/tcp.zig     -> Socket(Ip, max_asm_segs)              |
|    socket/udp.zig     -> Socket(Ip)                            |
|    socket/icmp.zig    -> Socket(Ip)                            |
|    socket/raw.zig     -> Socket(Ip, config)                    |
|    socket/dns.zig     -> Socket(Ip)                            |
|    iface: routing, source address selection                    |
|    stack: ingress routing, egress emit, socket dispatch        |
+================================================================+
|  TIER 3: ALREADY ADDRESS-FREE (no changes needed)             |
|                                                                |
|    wire/tcp.zig       TcpRepr has ports/flags/seq, no addrs   |
|    wire/udp.zig       UdpRepr has ports only                  |
|    wire/icmp.zig      ICMPv4 message types (v4-specific but   |
|                       parse/emit takes addresses as params)    |
|    wire/checksum.zig  Pure computation                        |
|    wire/ethernet.zig  Link layer, IP-agnostic                 |
|    storage/*          Pure data structures                    |
|    time.zig           Pure time types                         |
|    phy.zig            Device wrappers, IP-agnostic            |
+================================================================+
```

---

## Phase 0: Comptime Refactor (No New Protocols)

This is the critical foundation. Pure refactor -- every existing test must still
pass. No new functionality, no new protocols. We validate the comptime interface
against real code before IPv6 adds complexity.

### Step 0.1: Define the Ip Comptime Contract

New file: `src/wire/ip.zig`

This module documents (and optionally validates) the compile-time interface that
an IP version type must satisfy. Both `ipv4` and (later) `ipv6` conform to it.

```
Required declarations on an Ip type:
+-------------------------------------------+-------------+-----------+
| Declaration                               | IPv4        | IPv6      |
+-------------------------------------------+-------------+-----------+
| pub const Address: type                   | [4]u8       | [16]u8    |
| pub const UNSPECIFIED: Address            | {0,0,0,0}   | {0}**16   |
| pub const ADDRESS_LEN: comptime_int       | 4           | 16        |
| pub fn isUnspecified(Address) bool        | all zeros   | all zeros |
| pub fn isMulticast(Address) bool          | 224.0.0.0/4 | ff00::/8  |
| pub fn isBroadcast(Address) bool          | true/false  | false     |
| pub fn isLinkLocal(Address) bool          | 169.254/16  | fe80::/10 |
| pub fn isLoopback(Address) bool           | 127/8       | ::1       |
| pub fn format(Address) []const u8         | dotted quad | colon hex |
+-------------------------------------------+-------------+-----------+
```

The contract is structural (duck-typed), not a Zig interface. We use
`@hasDecl` / `@TypeOf` checks only if we need compile-time error messages.
The simpler path: just use `Ip.Address` etc. and let the compiler error
naturally if a declaration is missing.

### Step 0.2: Make ipv4.zig Conform

Ensure `src/wire/ipv4.zig` already exports everything the contract requires.
Most of it already exists. Gaps to fill:

- `ADDRESS_LEN` -- add `pub const ADDRESS_LEN: comptime_int = 4;`
- `format()` -- add if not present (for debug/test output)
- Verify all function signatures match the contract

No breaking changes. Additive only.

### Step 0.3: Extract Generic Types from iface.zig

Currently `IpCidr`, `Route`, `Routes`, `IpMeta`, `IpPayload` are concrete
IPv4 types defined inside `iface.zig`. Refactor them to be generic:

Before:
```
// iface.zig
pub const IpCidr = struct {
    address: ipv4.Address,
    prefix_len: u6,
    pub fn contains(self, addr: ipv4.Address) bool { ... }
};
```

After:
```
// iface.zig  (or a shared types module)
pub fn IpCidr(comptime Ip: type) type {
    return struct {
        address: Ip.Address,
        prefix_len: u6,   // u6 for v4 (max 32), u7 for v6 (max 128)
        pub fn contains(self: @This(), addr: Ip.Address) bool { ... }
    };
}
```

The prefix_len width question:

```
  IPv4: prefix_len 0..32  -> u6 is sufficient
  IPv6: prefix_len 0..128 -> u7 needed, or just use u8

  Decision: use u8 for both. The comptime Ip type can define a
  MAX_PREFIX_LEN constant. Validation at set-time, not type-time.
  This avoids needing a comptime-computed integer type for the field.
```

Types to extract and parameterize:

```
  iface.IpCidr        -> IpCidr(Ip)
  iface.Route         -> Route(Ip)
  iface.Routes        -> Routes(Ip)
  iface.IpMeta        -> IpMeta(Ip)
```

`IpPayload` and `Response` stay IPv4-specific for now (they carry ICMPv4
payloads and ARP replies). IPv6 will get its own response types in Phase 2.

### Step 0.4: Parameterize Socket Types

Each socket gains an `Ip` comptime parameter. The address type flows through
Endpoint, ListenEndpoint, Tuple, DispatchResult, and all method signatures.

```
BEFORE                              AFTER
------                              -----
socket/tcp.zig:                     socket/tcp.zig:
  Socket(max_asm_segs)               Socket(Ip, max_asm_segs)
  Endpoint { addr: ipv4.Address }    Endpoint { addr: Ip.Address }
  connect(remote_addr: ipv4.Addr.)   connect(remote_addr: Ip.Address)
  process(src: ipv4.Address, ...)    process(src: Ip.Address, ...)

socket/udp.zig:                     socket/udp.zig:
  Socket(config)                     Socket(Ip, config)
  Metadata { .addr: ipv4.Address }   Metadata { .addr: Ip.Address }

socket/icmp.zig:                    socket/icmp.zig:
  Socket(config)                     Socket(Ip, config)
  Packet { addr: ipv4.Address }      Packet { addr: Ip.Address }

socket/raw.zig:                     socket/raw.zig:
  Socket(config)                     Socket(Ip, config)
  Packet { addr: ipv4.Address }      Packet { addr: Ip.Address }

socket/dns.zig:                     socket/dns.zig:
  Socket (plain struct)              Socket(Ip)
  Addresses { [4][4]u8 }            Addresses { [4]Ip.Address }
```

DHCPv4 stays untouched -- it is protocol-inherent.

### Step 0.5: Parameterize iface.zig Interface

The `Interface` struct currently has IPv4 addresses, IPv4 multicast groups,
and calls ARP/IGMP directly. We split it:

```
Interface (today, monolithic)
+---------------------------------------------+
| ip_addrs: [4]IpCidr                         |
| multicast_groups: [4]?ipv4.Address           |
| neighbor_cache: NeighborCache               |
| routes: Routes                              |
| processEthernet() -> processArp/processIpv4 |
| processIcmp, processTcp, processUdp         |
+---------------------------------------------+

Interface (after refactor)
+---------------------------------------------+
|                                             |
|  Generic over Ip:                           |
|    ip_addrs: [N]IpCidr(Ip)                  |
|    routes: Routes(Ip)                       |
|    hasIpAddr(Ip.Address) bool               |
|    getSourceAddress(Ip.Address) ?Ip.Address  |
|    inSameNetwork(Ip.Address) bool           |
|    route(Ip.Address) ?Ip.Address            |
|                                             |
|  IPv4-inherent (stays concrete):            |
|    neighbor_cache: NeighborCache            | <- ARP-based
|    multicast_groups: [4]?ipv4.Address       | <- IGMP-based
|    processArp()                             |
|    processIcmpv4()                          |
|                                             |
+---------------------------------------------+
```

The cleanest approach: extract the generic parts into a function that returns
a type, keep the protocol-inherent parts as concrete fields.

```
pub fn IpState(comptime Ip: type) type {
    return struct {
        ip_addrs: [MAX_ADDR_COUNT]IpCidr(Ip),
        ip_addr_count: u3,
        routes: Routes(Ip),

        pub fn hasIpAddr(self, addr: Ip.Address) bool { ... }
        pub fn getSourceAddress(self, dst: Ip.Address) ?Ip.Address { ... }
        pub fn route(self, dst: Ip.Address) ?Ip.Address { ... }
    };
}

pub const Interface = struct {
    hardware_addr: ethernet.Address,
    any_ip: bool,

    // Protocol-inherent IPv4 subsystems
    neighbor_cache: NeighborCache,        // ARP-based
    multicast_groups: [...],              // IGMP-based
    v4: IpState(ipv4),                    // IPv4 addresses + routes

    // Later (Phase 2): v6: IpState(ipv6),
    //   ndp_cache: NdpCache,
    //   mld_groups: [...],
};
```

### Step 0.6: Parameterize stack.zig SocketConfig and Dispatch

The SocketConfig struct gains version-typed socket fields:

```
BEFORE                                  AFTER
------                                  -----
SocketConfig = struct {                 SocketConfig = struct {
  tcp_sockets: []*TcpSocket,             tcp4_sockets: []*TcpSocket(ipv4, 4),
  udp_sockets: []*UdpSocket,             udp4_sockets: []*UdpSocket(ipv4, cfg),
  icmp_sockets: []*IcmpSocket,           icmp4_sockets: []*IcmpSocket(ipv4, cfg),
  raw_sockets: []*RawSocket,             raw4_sockets: []*RawSocket(ipv4, cfg),
  dhcp_sockets: []*DhcpSocket,           dhcp_sockets: []*DhcpSocket,  (always v4)
  dns_sockets: []*DnsSocket,             dns4_sockets: []*DnsSocket(ipv4),
};                                        // v6 variants added in Phase 2
                                        };
```

The ingress pipeline dispatches by EtherType:

```
poll(timestamp, device)
  |
  +-> receive frame from device
  |
  +-> parse Ethernet header
       |
       +-- EtherType.arp  --> processArp()      [always IPv4]
       |
       +-- EtherType.ipv4 --> processIpv4Ingress()
       |     |
       |     +-> parse ipv4.Repr
       |     +-> reassemble fragments (if fragmented)
       |     +-> match protocol field:
       |          tcp  -> routeToSockets(tcp4_sockets, ...)
       |          udp  -> routeToSockets(udp4_sockets, ...)
       |          icmp -> routeToSockets(icmp4_sockets, ...)
       |          igmp -> processIgmp()
       |          *    -> routeToSockets(raw4_sockets, ...)
       |
       +-- EtherType.ipv6 --> processIpv6Ingress()  [Phase 2]
             |
             +-> parse ipv6.Repr
             +-> walk extension headers
             +-> match next-header:
                  tcp    -> routeToSockets(tcp6_sockets, ...)
                  udp    -> routeToSockets(udp6_sockets, ...)
                  icmpv6 -> NDP/MLD/echo dispatch
                  *      -> routeToSockets(raw6_sockets, ...)
```

The `routeToSockets` function is generic -- it works with any socket slice
whose element type has `accepts()` and `process()` methods. This is already
how the code works via comptime duck-typing.

### Step 0.7: Update Tests

All existing tests use IPv4. After the refactor:

- Test helpers instantiate sockets with explicit `ipv4` parameter:
  `Socket(ipv4, 4)` instead of `Socket(4)`
- `IpCidr(ipv4)` instead of `IpCidr`
- `Route(ipv4)` instead of `Route`
- Test semantics are identical -- only type signatures change
- 521 tests must still pass

### Step 0.8: Update root.zig Exports

```
pub const wire = struct {
    pub const ip = @import("wire/ip.zig");       // NEW: comptime contract
    pub const ipv4 = @import("wire/ipv4.zig");
    // ipv6 added in Phase 1
    pub const checksum = ...;
    pub const ethernet = ...;
    pub const arp = ...;
    pub const tcp = ...;
    pub const udp = ...;
    pub const icmp = ...;
    pub const igmp = ...;
    pub const dhcp = ...;
    pub const dns = ...;
};
```

### Phase 0 Dependency Graph

```
  0.1  Define Ip contract (wire/ip.zig)
   |
  0.2  Conform ipv4.zig
   |
   +--------+---------+
   |        |         |
  0.3     0.4       (independent)
  Extract  Param.
  iface    sockets
  types
   |        |
   +---+----+
       |
      0.5  Parameterize Interface
       |
      0.6  Parameterize Stack + SocketConfig
       |
      0.7  Update all tests
       |
      0.8  Update root.zig exports
```

### Phase 0 Risk: IpCidr Arithmetic

IPv4 `IpCidr` uses `u32` bit operations (`addrToU32`, shifts, masks). IPv6
needs `u128` or byte-level operations on `[16]u8`. Two approaches:

Option A: Comptime-selected integer width
```
const IntType = if (Ip.ADDRESS_LEN == 4) u32 else u128;
```
Zig supports u128 natively. This keeps the same algorithm for both.

Option B: Byte-level operations for both
```
fn contains(self, addr: Ip.Address) bool {
    // iterate bytes, apply mask per-byte
}
```
More portable, avoids u128 on targets that don't have native 128-bit ops.

Decision: Option A. Zig's u128 works on all targets (compiler handles
lowering), and the bit-math is cleaner. We can always revisit if profiling
shows u128 as a bottleneck on specific freestanding targets.

---

## Phase 1: IPv6 Wire Formats

With the comptime foundation from Phase 0, we implement IPv6 wire types.
Each new module mirrors the pattern of its IPv4 counterpart.

### New Files

| File | Reference | Description |
|------|-----------|-------------|
| `src/wire/ipv6.zig` | `ref/smoltcp/src/wire/ipv6.rs` | IPv6 header parse/emit, Address=[16]u8, conforms to Ip contract |
| `src/wire/icmpv6.zig` | `ref/smoltcp/src/wire/icmpv6.rs` | ICMPv6: echo, dest-unreachable, packet-too-big, time-exceeded, param-problem. Also carries NDP and MLD message types |
| `src/wire/ndisc.zig` | `ref/smoltcp/src/wire/ndisc.rs` | NDP (RFC 4861): Router Solicitation/Advertisement, Neighbor Solicitation/Advertisement, Redirect |
| `src/wire/ndiscoption.zig` | `ref/smoltcp/src/wire/ndiscoption.rs` | NDP options: Source/Target Link-Layer Address, Prefix Information, Redirected Header |
| `src/wire/ipv6ext_header.zig` | `ref/smoltcp/src/wire/ipv6ext_header.rs` | Generic extension header base (next_header + length) |
| `src/wire/ipv6fragment.zig` | `ref/smoltcp/src/wire/ipv6fragment.rs` | Fragment extension header (RFC 8200 S4.5): offset, M-bit, identification |
| `src/wire/ipv6hbh.zig` | `ref/smoltcp/src/wire/ipv6hbh.rs` | Hop-by-Hop Options header: router alert, RPL option |
| `src/wire/ipv6option.zig` | `ref/smoltcp/src/wire/ipv6option.rs` | IPv6 option TLV iterator with skip/discard action semantics |
| `src/wire/ipv6routing.zig` | `ref/smoltcp/src/wire/ipv6routing.rs` | Routing extension header: Type 2 (Mobile IPv6), RPL source routing |
| `src/wire/mld.zig` | `ref/smoltcp/src/wire/mld.rs` | MLDv2 (RFC 3810): Multicast Listener Query/Report |

### ipv6.zig Key Types

```
pub const Address = [16]u8;
pub const ADDRESS_LEN: comptime_int = 16;
pub const UNSPECIFIED: Address = .{0} ** 16;
pub const LOOPBACK: Address = .{0} ** 15 ++ .{1};
pub const LINK_LOCAL_ALL_NODES: Address = ...;    // ff02::1
pub const LINK_LOCAL_ALL_ROUTERS: Address = ...;  // ff02::2

pub const Protocol = enum(u8) {   // "Next Header" values
    hop_by_hop = 0,
    tcp = 6,
    udp = 17,
    routing = 43,
    fragment = 44,
    icmpv6 = 58,
    no_next_header = 59,
    _,
};

pub const Repr = struct {
    src_addr: Address,
    dst_addr: Address,
    next_header: Protocol,
    hop_limit: u8,
    payload_len: u16,
};

// Ip contract functions
pub fn isUnspecified(addr: Address) bool { ... }
pub fn isMulticast(addr: Address) bool { return addr[0] == 0xff; }
pub fn isBroadcast(addr: Address) bool { return false; } // IPv6 has no broadcast
pub fn isLinkLocal(addr: Address) bool { return addr[0] == 0xfe and (addr[1] & 0xc0) == 0x80; }
pub fn isLoopback(addr: Address) bool { ... }
```

### Test Strategy for Phase 1

Every wire module gets tests transliterated from smoltcp's corresponding Rust
test module, following the same tagging convention: `// [smoltcp:wire/ipv6:test_name]`.

Estimated: ~60-80 new tests across all Phase 1 wire modules.

---

## Phase 2: IPv6 Iface + Stack Integration

This phase connects the wire formats to the processing pipeline and brings
up a working IPv6 data path.

### 2.1: NDP Neighbor Cache

New neighbor resolution subsystem for IPv6, separate from the ARP-based cache.

```
Interface {
    neighbor_cache: NeighborCache,   // existing ARP (IPv4)
    ndp_cache: NdpCache,            // NEW: NDP (IPv6)
}
```

NDP uses ICMPv6 Neighbor Solicitation/Advertisement instead of ARP.
The cache structure is similar (address -> MAC, with timeout), but the
resolution protocol is entirely different:

```
IPv4 resolution:        IPv6 resolution:
  ARP Request (bcast)     ICMPv6 Neighbor Solicitation (multicast)
  ARP Reply               ICMPv6 Neighbor Advertisement
  Gratuitous ARP          Unsolicited Neighbor Advertisement
```

### 2.2: IPv6 Ingress Pipeline

Add `processIpv6Ingress` to the stack, mirroring `processIpv4Ingress`:

```
processIpv6Ingress(ip6_repr, payload):
  1. Walk extension headers (hop-by-hop, routing, fragment)
  2. Handle fragments -> reassemble (IPv6 reassembler, extension-header based)
  3. Match final next_header:
     - tcp    -> routeToSockets(tcp6_sockets, ...)
     - udp    -> routeToSockets(udp6_sockets, ...)
     - icmpv6 -> processIcmpv6():
         - Echo Request/Reply -> auto-reply or route to icmp6 sockets
         - Neighbor Solicitation -> NDP cache update + advertisement reply
         - Neighbor Advertisement -> NDP cache update
         - Router Advertisement -> SLAAC processing (step 2.6)
         - Router Solicitation -> (if acting as router)
         - MLD Query -> MLD report (step 2.4)
         - Dest Unreachable / Packet Too Big / etc. -> route to icmp6 sockets
     - *      -> routeToSockets(raw6_sockets, ...)
```

### 2.3: IPv6 Fragmentation / Reassembly

IPv6 fragmentation is fundamentally different from IPv4:

```
IPv4: fragmentation fields in the base header (flags + frag_offset + id)
IPv6: fragmentation is an extension header (next_header=44)
      Only the source fragments; routers never fragment.
      Minimum MTU is 1280 (vs IPv4's 576).
      Fragment ID is 32-bit (vs IPv4's 16-bit).
```

New `Ipv6Reassembler` in `fragmentation.zig` (or separate file), using the
existing `Assembler` for hole tracking but with a different key type:

```
Ipv6FragKey = struct { src: [16]u8, dst: [16]u8, id: u32 }
```

### 2.4: MLD Multicast Group Management

IPv6 equivalent of IGMP. Managed separately from IPv4 multicast groups:

```
Interface {
    multicast_groups: [4]?ipv4.Address,        // existing, IGMP
    multicast_groups_v6: [4]?ipv6.Address,     // NEW, MLD
}
```

### 2.5: IPv6 Egress Path

`emitIpv6Frame`: builds Ethernet + IPv6 headers, NDP neighbor lookup for
destination MAC (instead of ARP), fragments if payload > 1280 - 40.

### 2.6: SLAAC (RFC 4862)

Stateless Address Autoconfiguration:
- Send Router Solicitation on interface up
- Process Router Advertisement: extract prefix, compute interface ID from MAC
- Configure link-local address (fe80::) from MAC (EUI-64)
- Configure global address from advertised prefix + interface ID
- Prefix lifetime tracking (preferred / valid)

### 2.7: Stack SocketConfig v6 Fields

```
SocketConfig = struct {
    // IPv4 (from Phase 0)
    tcp4_sockets: ...,
    udp4_sockets: ...,
    icmp4_sockets: ...,
    raw4_sockets: ...,
    dhcp_sockets: ...,
    dns4_sockets: ...,

    // IPv6 (Phase 2)
    tcp6_sockets: ...,
    udp6_sockets: ...,
    icmp6_sockets: ...,
    raw6_sockets: ...,
    dns6_sockets: ...,
};
```

### Estimated Tests

~80-120 new tests across NDP, ICMPv6 processing, IPv6 fragmentation,
MLD, SLAAC, and IPv6 socket routing.

---

## Phase 3: Medium::Ip (Layer 3 Raw)

Support for IP-level mediums (TUN devices, PPP links) where there is no
Ethernet framing and no link-layer neighbor discovery.

### What Changes

```
Current assumption: every frame is Ethernet
  -> parse Ethernet header -> extract EtherType -> dispatch

Medium::Ip: frames are raw IP packets
  -> peek at version nibble (4 or 6) -> dispatch directly
  -> no ARP, no NDP over link-layer (point-to-point)
  -> no MAC addresses needed for transmission
```

### Implementation

Add a `Medium` enum to device capabilities:

```
pub const Medium = enum {
    ethernet,   // Layer 2: Ethernet II frames, ARP/NDP for neighbor resolution
    ip,         // Layer 3: raw IP packets, point-to-point (no neighbor discovery)
};
```

The stack checks `device_caps.medium` at comptime (if capabilities are
comptime-known) or runtime to select the ingress/egress path:

```
Ethernet ingress:  parseEthernetHeader -> dispatch by EtherType
IP ingress:        peek version nibble -> dispatch to v4 or v6 directly

Ethernet egress:   neighbor lookup -> build Ethernet + IP header -> transmit
IP egress:         build IP header only -> transmit (no MAC needed)
```

### Estimated Scope

Small -- primarily conditionals in the stack's frame read/write paths.
~10-15 new tests (TUN-style loopback device, no-MAC transmission).

---

## Phase 4: IoT / Constrained Networks -- COMPLETE

### 4.1: IEEE 802.15.4 Wire Format

`src/wire/ieee802154.zig` -- MAC frame parsing:
- Frame types: Beacon, Data, Ack, MAC Command
- Addressing modes: Absent, Short (2 bytes), Extended (8 bytes)
- PAN ID handling

### 4.2: 6LoWPAN

Header compression for IPv6 over 802.15.4 (RFC 6282):

| File | Description |
|------|-------------|
| `src/wire/sixlowpan/iphc.zig` | IPHC: IPv6 header compression. Inline/elided address modes, traffic class/flow label compression |
| `src/wire/sixlowpan/nhc.zig` | NHC: Next Header Compression for extension headers and UDP |
| `src/wire/sixlowpan/frag.zig` | 6LoWPAN fragmentation (FRAG1/FRAGN headers, different from IPv6 fragmentation) |

Iface integration: decompression pipeline in ingress, compression in egress.

### 4.3: RPL (Routing Protocol for Low-Power Networks)

RFC 6550 -- only relevant for mesh networking:

| Module | Description |
|--------|-------------|
| `src/wire/rpl.zig` | DIS/DIO/DAO message formats, RPL options, Instance ID |
| `src/iface/rpl/` | Trickle timer, parent set, objective function, source routing table |

### Estimated Scope

Large (~150-200 tests). This is a self-contained feature set that does not
affect the IPv4/IPv6 core path. Can be developed independently.

---

## Phase 5: Polish and Remaining Features

### 5.1: IPsec Wire Formats

Wire-only (no socket). Useful for parsing/emitting but not for actual
IPsec processing (that requires crypto which is out of scope).

| File | Description |
|------|-------------|
| `src/wire/ipsec_ah.zig` | Authentication Header: next_header, SPI, sequence, ICV |
| `src/wire/ipsec_esp.zig` | Encapsulating Security Payload: SPI, sequence |

Small scope, ~10 tests each.

### 5.2: mDNS

Extend `socket/dns.zig` to support multicast DNS (RFC 6762):
- mDNS IPv4 address: 224.0.0.251:5353
- mDNS IPv6 address: ff02::fb:5353
- Query on multicast, respond on multicast
- Primarily addressing changes + multicast join in the stack

### 5.3: PcapWriter PHY Middleware

`src/phy.zig` addition: wraps a device and writes all frames to pcap format.
Useful for debugging. Takes a caller-provided write function (no allocator).

```
PcapWriter(comptime Device: type)
  .pcap_link_type: enum { ethernet, ip, ieee802154 }
  .mode: enum { both, rx_only, tx_only }
  .write_fn: fn([]const u8) void  -- caller-provided sink
```

### 5.4: Configurable Auto-ICMP-Echo-Reply

Currently zmoltcp always replies to ICMP echo requests at the iface level.
smoltcp has this as an opt-in feature flag. Add a bool field:

```
Interface {
    auto_icmp_echo_reply: bool = true,  // default on for backwards compat
}
```

Small change, ~2 tests.

### 5.5: PacketBuffer Optimization

smoltcp uses a dual-ring `PacketBuffer` (metadata ring + payload ring) for
UDP and ICMP sockets. zmoltcp currently uses `RingBuffer(Packet)` where
each Packet has a fixed-size payload array. The dual-ring approach is more
memory-efficient when packet sizes vary.

Evaluate whether this matters for Laminae's use case. If UDP packets are
consistently sized, the current approach may be fine.

---

## Milestone Summary

```
Phase 0: Comptime refactor        | 0 new protocols | 0 new tests (521 must pass)
Phase 1: IPv6 wire formats        | 10 new files    | ~60-80 new tests
Phase 2: IPv6 iface + stack       | 3-5 new files   | ~80-120 new tests
Phase 3: Medium::Ip               | 0 new files     | ~10-15 new tests
Phase 4: IoT (optional)           | 6-8 new files   | ~150-200 new tests
Phase 5: Polish                   | 2-4 new files   | ~30-50 new tests

Total (Phases 0-3): ~670-740 tests, full IPv4+IPv6 Ethernet stack
Total (all phases): ~850-950 tests, full smoltcp feature parity
```

---

## What "Drop-In Replacement" Means After Completion

After Phases 0-3, zmoltcp supports every protocol and feature that smoltcp
does for Ethernet-based IPv4+IPv6 networking. Any application using smoltcp
over Ethernet can be ported to zmoltcp with equivalent functionality.

After Phase 4, IoT/constrained network support matches smoltcp.

After Phase 5, the remaining convenience features and optimizations are in
place. At that point zmoltcp is a complete, idiomatic-Zig replacement for
smoltcp with zero runtime overhead from the dual-stack abstraction.
